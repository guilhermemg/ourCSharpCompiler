grammar org.xtext.example.mydsl1.OurCS2 with org.eclipse.xtext.common.Terminals

generate ourCS2 "http://www.xtext.org/example/mydsl1/OurCS2"

Model:
//	greetings+=Greeting*;
	proRule1+=ProRule1*;

ProRule1:
	INPUT;

INPUT:
	VARIABLE_DECL |
	STATEMENT |
	CLASS_DECLARATION;

// TYPES --------------------------------------------------------------------------

PREDEFINED_TYPE:
	'bool' | 'byte' | 'char' | 'decimal' | 'double' | 'float' | 'int' | 'long' | 'object' | 'sbyte' | 'short' | 'string' |
	'uint' | 'ulong' | 'ushort';

TYPE:
	NON_ARRAY_TYPE RANK_SPECIFIER*;

NON_ARRAY_TYPE:
//QUALIFIED_TYPE |
	BUILT_IN_TYPE;

INTEGRAL_TYPE:
	'sbyte' |
	'byte' |
	'short' |
	'ushort' |
	'int' |
	'uint' |
	'long' |
	'ulong' |
	'char';

BUILT_IN_TYPE:
	INTEGRAL_TYPE |
	//BUILT_IN_CLASS_TYPE |
	'bool' |
	'decimal' |
	'float' |
	'double';

RANK_SPECIFIER:
	'[' ','* ']';	

//LITERAL -------------------------------------------------------------------------
BOOL_LITERAL:
	'true' | 'false';

NULL_LITERAL:
	'null';

INT_LITERAL:
	INT;

STRING_LITERAL:
	STRING;

//REAL_TYPE_SUFFIX:
//    'F' |
//    'f' |
//    'D' |
//    'd' |
//    'M' |
//    'm';
//
//REAL_LITERAL:
//    (INT_LITERAL '.' INT_LITERAL+ EXPONENT_PART? REAL_TYPE_SUFFIX?) |
//    (INT_LITERAL+ EXPONENT_PART REAL_TYPE_SUFFIX?) |
//    (INT_LITERAL+ REAL_TYPE_SUFFIX);
//
//EXPONENT_PART:
//    ('e' SIGN? INT_LITERAL+) |
//    ('E' SIGN? INT_LITERAL+);
//
//SIGN:
//    '+' |
//    '-';

LITERAL:
	BOOL_LITERAL | NULL_LITERAL | INT_LITERAL | STRING_LITERAL /*| REAL_LITERAL*/;

// EXPRESSION ----------------------------------------------------------------

ASSIGN_OPERATOR:
	'=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=';

REL_EXPRESSOIN:
	'==' | '!=' | '<=' | '>=' | '<' | '>';

BOOL_OPERATORS:
	'||' | '&&' | BAR | AMPERSAND | '%';

PRIMARY_EXPRESSION:
//'new' NON_ARRAY_TYPE '[' EXPRESSION_LIST ']' RANK_SPECIFIER* ARRAY_INITIALIZER? |
//'new' ARRAY_TYPE ARRAY_INITIALIZER |
	( LITERAL ) | 
	( ID ) |
//	( '(' EXPRESSION ')' ) |
	( PREDEFINED_TYPE '.' ID ) |
	( 'this' ) | 
	( 'base' '.' ID ) //|
//	( 'base' '[' EXPRESSION_LIST ']' ) |
//	( 'new' TYPE '(' ARGUMENT_LIST ')' ) |
//	( 'typeof' '(' TYPE_OR_VOID ')' ) |
//	( 'checked' '(' EXPRESSION ')' ) |
//	( 'unchecked' '(' EXPRESSION ')' )
    //PRIMARY_EXPRESSION '.' ID |
	//PRIMARY_EXPRESSION '(' ARGUMENT_LIST ')' |
	//PRIMARY_EXPRESSION '[' EXPRESSION_LIST ']' |
	//PRIMARY_EXPRESSION INCREMENT_DECREMENT |
;

//ARGUMENT:
//	('ref' | 'out')? EXPRESSION
//;
//
//ARGUMENT_LIST:
//	ARGUMENT ','?
//;
//
//TYPE_OR_VOID:
//	TYPE | 'void'	
//;

EXPRESSION_LIST:
	EXPRESSION ','?;

EXPRESSION:
	COND_EXPRESSION |
	UNA_EXP;// | 
//	ARITHMETIC_EXP;

COND_EXPRESSION:
	PRIMARY_EXPRESSION COND_EXPRESSION_LINE;

COND_EXPRESSION_LINE:
	(BOOL_OPERATORS EXPRESSION) |
	('^' EXPRESSION) |
	(REL_EXPRESSOIN EXPRESSION)
;

UNA_EXP:
	UNARY_EXPRESSION (ASSIGN_OPERATOR EXPRESSION)?;

UNARY_EXPRESSION:
	( UNA_EXP_OPERATOR UNARY_EXPRESSION ) | 
	( '(' TYPE ')' UNARY_EXPRESSION ) |
	(PRIMARY_EXPRESSION); 

//ARITHMETIC_EXP:
//	 ARITHMETIC_EXP_LINE?
//;
//
//ARITHMETIC_EXP_LINE:
//	EXPRESSION_SHIFT_OPERATOR EXPRESSION ARITHMETIC_EXP_LINE |
//	PLUS EXPRESSION ARITHMETIC_EXP_LINE |
//	MINUS EXPRESSION ARITHMETIC_EXP_LINE |
//	'*' EXPRESSION ARITHMETIC_EXP_LINE |
//	'/' EXPRESSION ARITHMETIC_EXP_LINE |
//	'%' EXPRESSION ARITHMETIC_EXP_LINE
//;

BAR:
	'|';

AMPERSAND:
	'&';

INCREMENT_DECREMENT:
	'++' | '--';

UNA_EXP_OPERATOR:
	PLUS | MINUS | INCREMENT_DECREMENT | '!' | '~' | '*';

EXPRESSION_SHIFT_OPERATOR:
    "<<" |
    ">>";

PLUS:
	'+';

MINUS:
	'-';

// VARIABLE DECLARATION --------------------------------------------------------

VARIABLE_DECL:
	PREDEFINED_TYPE ID ';'
;

// STATEMENTS ------------------------------------------------------------------
ASSIGN_STMT:
	(ASSIGN_STMT_LINE ';'?) |
	
	(INCREMENT_DECREMENT name=ID) |
	(name=ID INCREMENT_DECREMENT) |
	
	(SIMPLE_ASSIGN_STATEMENT) 
;

ASSIGN_STMT_LINE:
	(PREDEFINED_TYPE name=ID ASSIGN_OPERATOR LITERAL) |
	(PREDEFINED_TYPE name=ID ASSIGN_OPERATOR EXPRESSION)
;

SIMPLE_ASSIGN_STATEMENT:
	(name=ID INCREMENT_DECREMENT ';') |
	(INCREMENT_DECREMENT name=ID ';') |
	(name=ID ASSIGN_OPERATOR LITERAL';')	
;

IF_STATEMENT:
	'if' '(' EXPRESSION ')' BLOCK location=ELSE_PART?;

ELSE_PART:
	'else' BLOCK;

SWITCH_LABEL:
	("case" EXPRESSION ":") | ("default" ":");

SWITCH_SECTION:
	SWITCH_LABEL+ location=STATEMENT+;

SWITCH_STATEMENT:
	"switch" "(" ID ")" "{" location=SWITCH_SECTION* "}";

BLOCK:
	"{" location=STATEMENT* "}";

ITERATION_STATEMENT:
	WHILE_STATEMENT | DO_STATEMENT | FOR_STATEMENT
	//    FOREACH_STATEMENT
;

FOR_STATEMENT:
	'for' '(' ASSIGN_STMT? COND_EXPRESSION ';' ASSIGN_STMT? ')' location=BLOCK;

WHILE_STATEMENT:
	'while' '(' COND_EXPRESSION ')' location=BLOCK;

DO_STATEMENT:
	'do' location=BLOCK 'while' '(' COND_EXPRESSION ')' ';';

JUMP_STATEMENT:
    BREAK_STATEMENT |
    CONTINUE_STATEMENT |
    GOTO_STATEMENT |
    RETURN_STATEMENT |
    THROW_STATEMENT
;

BREAK_STATEMENT:
    "break" ";"
;

CONTINUE_STATEMENT:
    "continue" ";"
;    

GOTO_STATEMENT:
    ("goto" ID ";") |
    ("goto" "case" COND_EXPRESSION ";") |
    ("goto" "default" ";")
;

RETURN_STATEMENT:
    "return" EXPRESSION? ";"
;

THROW_STATEMENT:
    "throw" EXPRESSION? ";"
;

BUILT_IN_CLASS_TYPE:
    "object" |
    "string"
;

GENERAL_CATCH_CLAUSE:
    "catch" BLOCK;

SPECIFIC_CATCH_CLAUSE:
    "catch" "(" BUILT_IN_CLASS_TYPE ID? ")" BLOCK
;

FINALLY_CLAUSE:
    "finally" BLOCK;

CATCH_CLAUSES:
    //(location=SPECIFIC_CATCH_CLAUSE+ location=GENERAL_CATCH_CLAUSE?) |
    (location=SPECIFIC_CATCH_CLAUSE* location=GENERAL_CATCH_CLAUSE)
;

TRY_STATEMENT_LINE:
	(CATCH_CLAUSES location=FINALLY_CLAUSE?) |
	(FINALLY_CLAUSE)
;

TRY_STATEMENT:
    "try" BLOCK location=TRY_STATEMENT_LINE 
;

STATEMENT:
	ASSIGN_STMT | IF_STATEMENT | ITERATION_STATEMENT |
	SWITCH_STATEMENT | JUMP_STATEMENT | TRY_STATEMENT
;

// ATTRIBUTES -------------------------------------------------------------------

ATTRIBUTES:
    ATTRIBUTES_SECTION*;

ATTRIBUTES_SECTION:
    '[' ( ATTRIBUTE_TARGET ':' )? ATTRIBUTE_LIST* ']';

ATTRIBUTE_TARGET:
    'field' |
    'event' |
    'method' |
    'module' |
    'param' |
    'property' |
    'return' |
    'type';

ATTRIBUTE_LIST:
    ATTRIBUTE ','?;

ATTRIBUTE:
    ATTRIBUTE_NAME ATTRIBUTE_ARGUMENTS?;

ATTRIBUTE_NAME:
    ID;

ATTRIBUTE_ARGUMENTS:
    '(' EXPRESSION_LIST* ')';

// classes ----------------------------------------------------------------------

CLASS_DECLARATION:
    ATTRIBUTES CLASS_MODIFIER* 'class' ID /*CLASS_BASE?*/ CLASS_BODY ';'?;

CLASS_MODIFIER:
    'new' |
    'public' |
    'protected' |
    'internal' |
    'private' |
    'abstract' |
    'sealed';
    
CLASS_BODY:
    '{' location=CLASS_MEMBER_DECLARATION* '}';

CLASS_MEMBER_DECLARATION:
    CONST_OR_FIELD_DECL
//    method-declaration |
//    property-declaration |
//    event-declaration |
//    indexer-declaration |
//    operator-declaration |
//    constructor-declaration |
//    destructor-declaration |
//    static-constructor-declaration |
//    type-declaration   
;

CONST_OR_FIELD_DECL:
	ATTRIBUTES CONST_OR_FIELD_DECL_LINE
;

CONST_OR_FIELD_DECL_LINE:
	CONSTANT_DECLARATION | FIELD_DECLARATION
;

CONSTANT_DECLARATION:
    CONSTANT_MODIFIER* 'const' ASSIGN_STMT;

CONSTANT_MODIFIER:
    'new' |
    'public' |
    'protected' | 
    'internal' |
    'private';

FIELD_DECLARATION:
    (FIELD_MODIFIER | CONSTANT_MODIFIER)* TYPE ASSIGN_STMT;

FIELD_MODIFIER:
    'static' |
    'readonly' |
    'volatile';
